# Copyright (C) 2016 OLogN Technologies AG
#
# This source file is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License version 2
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from smartanthill_phc import builtin, c_node, root
from smartanthill_phc.common import base, decl
from smartanthill_phc.common.base import TypeNode
from smartanthill_phc.common.child import Child


class ParserStmtNode(base.StatementNode):

    '''
    Implementation of autogenerated parser
    '''

    def __init__(self):
        '''
        Constructor
        '''
        super(ParserStmtNode, self).__init__()
        self.struct_type = Child(self, TypeNode)
        self.parser_elements = []


class ComposerStmtNode(base.StatementNode):

    '''
    Implementation of autogenerated composer
    '''

    def __init__(self):
        '''
        Constructor
        '''
        super(ComposerStmtNode, self).__init__()
        self.parser_elements = []


def create_manifest(compiler, ctx, prefix, zepto_plugin):
    '''
    Creates support classes from plugin manifest
    '''

    node = compiler.init_node(root.PluginManifestNode(), ctx)
    node.txt_prefix = prefix

    config_name = prefix + "_plugin_config"
    struct_name = prefix + "_plugin_data"
    parser_name = prefix + "_plugin_parser_read"
    writer_name = prefix + "_plugin_reply_write"

    req = _get_elements(zepto_plugin.get_request_fields())
    _make_parser(compiler, ctx, node.elements, struct_name, parser_name, req)

    resp = _get_elements(zepto_plugin.get_response_fields())
    _make_composer(compiler, ctx, node.elements, writer_name, resp)

    per = _get_elements(zepto_plugin.get_peripheral())
    _add_struct(compiler, ctx, node.elements, config_name, per)

    return node


class _Element(object):

    def __init__(self, name, c_type):
        self.name = name
        self.c_type = c_type


def _get_elements(fields):

    result = []
    for current in fields:
        t = "".join(current['type'].split())
        if t == "encoded-uint[max=1]":
            c_type = "uint8_t"
        elif t == "encoded-uint[max=2]":
            c_type = "uint16_t"
        elif t == "encoded-int[max=2]":
            c_type = "int16_t"
        elif t in ("i2c[sda]", "i2c[scl]", "spi[sclk]", "spi[mosi]",
                   "spi[miso]", "spi[ss]", "analog", "digital", "pwm"):
            c_type = "uint8_t"
        else:
            assert False

        result.append(_Element(current['name'], c_type))

    return result


def _add_struct(compiler, ctx, elements, name, per):

    if len(per) != 0:
        st = compiler.init_node(c_node.StructTypeDeclNode('_' + name),
                                ctx)

        for each in per:
            att = compiler.init_node(c_node.AttributeDeclarationNode(), ctx)
            att.txt_name = each.name
            t = compiler.init_node(c_node.SimpleTypeNode(), ctx)
            t.txt_name = each.c_type
            att.declaration_type.set(t)

            st.members.add(att)

        tpd = compiler.init_node(c_node.TypedefStmtNode(), ctx)
        tpd.txt_name = name
        t = compiler.init_node(c_node.RefTypeNode(), ctx)
        t.set_type(st)
        tpd.typedef_type.set(t)

        elements.add(st)
        elements.add(tpd)


def _get_parser_func_name(name):

    if name == 'uint8_t':
        return 'byte'
    elif name == 'uint16_t':
        return 'encoded_uint16'
    elif name == 'int16_t':
        return 'encoded_signed_int16'
    else:
        assert False


def _make_parser(compiler, ctx, elements, struct_name, func_name, req):

    if len(req) != 0:
        _add_struct(compiler, ctx, elements, struct_name, req)

        d = _make_func_definition(compiler, ctx)

        txt = "%s %s( ZEPTO_PARSER* sa_po );" % (struct_name, func_name)
        f = builtin.pseudo_parser(compiler, ctx, txt)
        f.bool_static = True
        f.bool_inline = True
        d.declaration.set(f)

        s = compiler.init_node(ParserStmtNode(), ctx)
        t = compiler.init_node(c_node.SimpleTypeNode(), ctx)
        t.txt_name = struct_name
        s.struct_type.set(t)
        s.parser_elements = req

        d.statement_list.get().statements.add(s)

        elements.add(d)


def _make_composer(compiler, ctx, elements, func_name, resp):

    if len(resp) != 0:

        d = _make_func_definition(compiler, ctx)

        txt = "void %s( REPLY_HANDLE sa_rh" % func_name
        for each in resp:
            txt += ", %s %s" % (each.c_type, each.name)
        txt += ");"

        f = builtin.pseudo_parser(compiler, ctx, txt)
        f.bool_static = True
        f.bool_inline = True
        d.declaration.set(f)

        s = compiler.init_node(ComposerStmtNode(), ctx)
        s.parser_elements = resp
        d.statement_list.get().statements.add(s)

        elements.add(d)


def _make_func_definition(compiler, ctx):

    st = compiler.init_node(decl.FunctionDefinitionNode(), ctx)
    stmt_list = compiler.init_node(base.StmtListNode(), ctx)
    st.statement_list.set(stmt_list)

    return st
